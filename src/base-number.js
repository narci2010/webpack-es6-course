// 二进制和八进制表示法
// ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。
const { log } = console
log(0b111110111 === 503) // true
log(0o767 === 503)
log(0x1f7 === 503)
// true

// 从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。
// 严格模式
;(function() {
  //   'use strict';
  //console.log(0o11 === 011)
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.

// 安全整数和 Number.isSafeInteger()
// 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。
// 如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。
// JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。
log(Math.pow(2, 53)) // 9007199254740992
log(Math.pow(2, 53) === Math.pow(2, 53) + 1) // true
// 上面代码中，超出 2 的 53 次方之后，一个数就不精确了。

Number.isInteger(3.0000000000000002) // true
// 上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。
// 类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。
// 这时，Number.isInteger也会误判。
log(Number.isInteger(5e-324)) // false
log(Number.isInteger(5e-325)) // true
// 上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。
// 总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。
log(Number.MAX_VALUE) //1.7976931348623157e+308
log(Number.MIN_VALUE) //5e-324
log(Number.MAX_SAFE_INTEGER)
log(Number.MIN_SAFE_INTEGER)
log(Number.MIN_SAFE_INTEGER === Number.MAX_SAFE_INTEGER)

// Number.EPSILON
// ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。
// 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，
// 小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。
log(Number.EPSILON === Math.pow(2, -52)) // true
log(Number.EPSILON) // 2.220446049250313e-16
log(Number.EPSILON.toFixed(20)) // "0.00000000000000022204"
// Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。

// 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。
// 0.1 + 0.2
// // 0.30000000000000004
// 0.1 + 0.2 - 0.3
// // 5.551115123125783e-17
// 5.551115123125783e-17.toFixed(20)
// // '0.00000000000000005551'
// 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。

// Math.clz32()
// Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。
log(Math.clz32(0)) // 32
log(Math.clz32(-1)) // 0

// 指数运算符
// ES2016 新增了一个指数运算符（**）。
log(2 ** 2) // 4
log(2 ** 3) // 8

// JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。
// 数值精度
// 根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。
// 第1位：符号位，0表示正数，1表示负数
// 第2位到第12位：指数部分
// 第13位到第64位：小数部分（即有效数字）
// 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。
// IEEE 754 规定，有效数字第一位默认总是1，不保存在64位浮点数之中。
// 也就是说，有效数字总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。
// 因此，JavaScript 提供的有效数字最长为53个二进制位。

// 数值范围
// 根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。
// 也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），
// 超出这个范围的数无法表示。
// 如果指数部分等于或超过最大正值1024，JavaScript 会返回Infinity（关于Infinity的介绍参见下文），这称为“正向溢出”；
// 如果等于或超过最小负值-1023（即非常接近0），JavaScript 会直接把这个数转为0，这称为“负向溢出”。
